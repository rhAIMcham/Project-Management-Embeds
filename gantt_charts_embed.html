<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600&display=swap" rel="stylesheet">
  <title>Critical Path Explorer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      font-family: "IBM Plex Sans", sans-serif;
      --blue: #4353A3;
      --teal: #5DC8B9;
      --red: #ef4444;
      --indigo: #6366f1;
    }

    body {
      background-color: #f9fafb;
      color: #111827;
      padding: 2rem;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    h1 {
      font-size: 2rem;
      margin-bottom: 0.5rem;
      color: var(--blue);
    }

    .subtitle {
      color: #6b7280;
      margin-bottom: 2rem;
      font-size: 0.95rem;
    }

    .project-selector {
      display: flex;
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .project-btn {
      padding: 0.75rem 1.5rem;
      border: 2px solid #e5e7eb;
      background: white;
      border-radius: 0.5rem;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 500;
      transition: all 0.2s;
    }

    .project-btn:hover {
      border-color: var(--teal);
    }

    .project-btn.active {
      background: var(--blue);
      color: white;
      border-color: var(--blue);
    }

    .chart-section {
      background: white;
      border-radius: 1rem;
      padding: 1.5rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      margin-bottom: 1.5rem;
    }

    .chart-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .chart-title {
      font-size: 1.25rem;
      font-weight: 600;
    }

    .duration {
      color: #6b7280;
      font-size: 0.9rem;
    }

    .duration strong {
      color: #111827;
      font-weight: 600;
    }

    .scale-header {
      display: grid;
      margin-left: 24px;
      margin-bottom: 0.5rem;
    }

    .scale-label {
      text-align: center;
      font-size: 0.75rem;
      color: #6b7280;
    }

    .chart-area {
      position: relative;
      margin-top: 1rem;
    }

    .task-row {
      position: absolute;
      left: 0;
      height: 110px;
    }

    .task-bar {
      position: relative;
      height: 80px;
      border-radius: 0.75rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: grab;
      transition: transform 0.1s;
    }

    .task-bar:active {
      cursor: grabbing;
    }

    .task-bar.critical {
      background: var(--red);
      color: white;
    }

    .task-bar.non-critical {
      background: var(--indigo);
      color: white;
    }

    .task-content {
      text-align: center;
      pointer-events: none;
    }

    .task-name {
      font-weight: 500;
      font-size: 0.9rem;
    }

    .task-info {
      font-size: 0.75rem;
      opacity: 0.9;
      margin-top: 0.25rem;
    }

    .corner-value {
      position: absolute;
      font-size: 0.65rem;
      background: rgba(255,255,255,0.3);
      padding: 0.15rem 0.35rem;
      border-radius: 0.25rem;
    }

    .es { top: 0.25rem; left: 0.25rem; }
    .ef { top: 0.25rem; right: 0.25rem; }
    .ls { bottom: 0.25rem; left: 0.25rem; }
    .lf { bottom: 0.25rem; right: 0.25rem; }

    .arrows-svg {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .legend {
      display: flex;
      gap: 2rem;
      align-items: center;
      padding: 1rem;
      background: #f9fafb;
      border-radius: 0.5rem;
      font-size: 0.9rem;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .legend-box {
      width: 1rem;
      height: 1rem;
      border-radius: 0.25rem;
    }

    .instructions {
      background: #eff6ff;
      border-left: 4px solid var(--blue);
      padding: 1rem;
      border-radius: 0.5rem;
      margin-bottom: 2rem;
    }

    .instructions h3 {
      font-size: 1rem;
      margin-bottom: 0.5rem;
      color: var(--blue);
    }

    .instructions p {
      color: #374151;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Critical Path Explorer</h1>
    <p class="subtitle">Drag tasks to explore how slack affects the critical path</p>

    <div class="instructions">
      <h3>How to use:</h3>
      <p>üéØ Drag any task bar left or right to change its start time<br>
      üìä Watch how the critical path (red tasks) changes as you move tasks beyond their slack<br>
      ‚ö†Ô∏è Moving a critical path task will shift dependent tasks and may extend the project deadline</p>
    </div>

    <div class="project-selector" id="project-selector"></div>

    <div class="chart-section">
      <div class="chart-header">
        <h2 class="chart-title" id="project-name"></h2>
        <div class="duration">Duration: <strong id="duration">0</strong> days</div>
      </div>

      <div class="scale-header" id="scale-header"></div>
      
      <div class="chart-area" id="chart-area">
        <div id="task-bars"></div>
        <svg class="arrows-svg" id="arrows-svg">
          <defs>
            <marker id="arrow-gray" markerWidth="8" markerHeight="8" refX="8" refY="4" orient="auto">
              <path d="M0,0 L8,4 L0,8 Z" fill="#9ca3af" />
            </marker>
            <marker id="arrow-red" markerWidth="8" markerHeight="8" refX="8" refY="4" orient="auto">
              <path d="M0,0 L8,4 L0,8 Z" fill="#ef4444" />
            </marker>
          </defs>
          <g id="arrow-paths"></g>
        </svg>
      </div>

      <div class="legend">
        <div class="legend-item">
          <div class="legend-box" style="background: var(--red);"></div>
          <span>Critical Path</span>
        </div>
        <div class="legend-item">
          <div class="legend-box" style="background: var(--indigo);"></div>
          <span>Non-Critical (has slack)</span>
        </div>
        <div>Slack = LS - ES</div>
      </div>
    </div>
  </div>

  <script>
    const PROJECTS = [
      {
        id: 1,
        name: "Website Development",
        tasks: [
          { id: "A", name: "Planning", duration: 3, deps: [] },
          { id: "B", name: "Design", duration: 4, deps: ["A"] },
          { id: "C", name: "Content", duration: 3, deps: ["A"] },
          { id: "D", name: "Development", duration: 5, deps: ["B", "C"] },
          { id: "E", name: "Testing", duration: 2, deps: ["D"] }
        ]
      },
      {
        id: 2,
        name: "Event Planning",
        tasks: [
          { id: "A", name: "Book Venue", duration: 2, deps: [] },
          { id: "B", name: "Catering", duration: 3, deps: [] },
          { id: "C", name: "Invitations", duration: 4, deps: ["A"] },
          { id: "D", name: "Setup Plan", duration: 2, deps: ["A", "B"] },
          { id: "E", name: "Final Check", duration: 1, deps: ["C", "D"] }
        ]
      },
      {
        id: 3,
        name: "Product Launch",
        tasks: [
          { id: "A", name: "Research", duration: 4, deps: [] },
          { id: "B", name: "Prototype", duration: 5, deps: ["A"] },
          { id: "C", name: "Marketing", duration: 3, deps: ["A"] },
          { id: "D", name: "Production", duration: 4, deps: ["B"] },
          { id: "E", name: "Launch", duration: 2, deps: ["C", "D"] }
        ]
      }
    ];

    const state = {
      currentProjectId: 1,
      minStart: {},
      dragging: null,
      unitWidth: 40
    };

    function getCurrentProject() {
      return PROJECTS.find(p => p.id === state.currentProjectId);
    }

    function computeCPM(tasks, minStart = {}) {
      const ES = {}, EF = {}, LS = {}, LF = {};
      const byId = {};
      tasks.forEach(t => byId[t.id] = t);

      // Topological sort
      const indeg = {};
      const graph = {};
      tasks.forEach(t => {
        indeg[t.id] = t.deps.length;
        t.deps.forEach(d => {
          graph[d] = graph[d] || [];
          graph[d].push(t.id);
        });
      });

      const queue = tasks.filter(t => indeg[t.id] === 0).map(t => t.id);
      const order = [];

      while (queue.length) {
        const u = queue.shift();
        order.push(u);
        (graph[u] || []).forEach(v => {
          indeg[v]--;
          if (indeg[v] === 0) queue.push(v);
        });
      }

      // Forward pass
      for (const id of order) {
        const t = byId[id];
        const predEF = t.deps.length ? Math.max(...t.deps.map(p => EF[p])) : 0;
        ES[id] = Math.max(predEF, minStart[id] || 0);
        EF[id] = ES[id] + t.duration;
      }

      const projectDuration = Math.max(...Object.values(EF));

      // Backward pass
      const succs = {};
      tasks.forEach(t => t.deps.forEach(d => {
        succs[d] = succs[d] || [];
        succs[d].push(t.id);
      }));

      for (const id of [...order].reverse()) {
        const t = byId[id];
        const s = succs[id] || [];
        LF[id] = s.length === 0 ? projectDuration : Math.min(...s.map(v => LS[v]));
        LS[id] = LF[id] - t.duration;
      }

      const slack = {};
      const critical = new Set();
      tasks.forEach(t => {
        slack[t.id] = LS[t.id] - ES[t.id];
        if (Math.abs(slack[t.id]) < 0.01) critical.add(t.id);
      });

      return { ES, EF, LS, LF, slack, critical, projectDuration };
    }

    function render() {
      const project = getCurrentProject();
      const computed = computeCPM(project.tasks, state.minStart);
      const maxTime = Math.ceil(computed.projectDuration * 1.2);

      document.getElementById('project-name').textContent = project.name;
      document.getElementById('duration').textContent = computed.projectDuration;

      renderScale(maxTime);
      renderTasks(project, computed, maxTime);
      renderArrows(project, computed, maxTime);
    }

    function renderScale(maxTime) {
      const scale = document.getElementById('scale-header');
      const cols = Math.ceil(maxTime) + 1;
      scale.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
      scale.innerHTML = '';
      
      for (let i = 0; i <= maxTime; i++) {
        const label = document.createElement('div');
        label.className = 'scale-label';
        label.textContent = i;
        scale.appendChild(label);
      }
    }

    function renderTasks(project, computed, maxTime) {
      const container = document.getElementById('task-bars');
      const chartArea = document.getElementById('chart-area');
      
      container.innerHTML = '';
      chartArea.style.height = (project.tasks.length * 110 + 20) + 'px';

      const chartWidth = document.getElementById('scale-header').offsetWidth;
      state.unitWidth = chartWidth / (maxTime + 1);

      project.tasks.forEach((task, idx) => {
        const start = state.minStart[task.id] ?? computed.ES[task.id];
        const isCritical = computed.critical.has(task.id);

        const row = document.createElement('div');
        row.className = 'task-row';
        row.style.top = (idx * 110) + 'px';

        const bar = document.createElement('div');
        bar.className = `task-bar ${isCritical ? 'critical' : 'non-critical'}`;
        bar.style.left = (24 + start * state.unitWidth) + 'px';
        bar.style.width = (task.duration * state.unitWidth) + 'px';
        bar.dataset.taskId = task.id;

        bar.innerHTML = `
          <div class="task-content">
            <div class="task-name">${task.id}: ${task.name}</div>
            <div class="task-info">Duration: ${task.duration} | Slack: ${computed.slack[task.id].toFixed(0)}</div>
          </div>
          <div class="corner-value es">ES: ${computed.ES[task.id]}</div>
          <div class="corner-value ef">EF: ${computed.EF[task.id]}</div>
          <div class="corner-value ls">LS: ${computed.LS[task.id]}</div>
          <div class="corner-value lf">LF: ${computed.LF[task.id]}</div>
        `;

        bar.addEventListener('mousedown', handleMouseDown);
        row.appendChild(bar);
        container.appendChild(row);
      });
    }

    function renderArrows(project, computed, maxTime) {
      const svg = document.getElementById('arrows-svg');
      const paths = document.getElementById('arrow-paths');
      const chartWidth = 24 + (maxTime + 1) * state.unitWidth;
      const chartHeight = project.tasks.length * 110 + 20;

      svg.setAttribute('viewBox', `0 0 ${chartWidth} ${chartHeight}`);
      paths.innerHTML = '';

      project.tasks.forEach((task, tgtIdx) => {
        const tgtStart = state.minStart[task.id] ?? computed.ES[task.id];
        const tgtX = 24 + tgtStart * state.unitWidth;
        const tgtY = tgtIdx * 110 + 40;

        task.deps.forEach(depId => {
          const pred = project.tasks.find(t => t.id === depId);
          if (!pred) return;

          const predIdx = project.tasks.indexOf(pred);
          const predStart = state.minStart[pred.id] ?? computed.ES[pred.id];
          const predEndX = 24 + (predStart + pred.duration) * state.unitWidth;
          const predY = predIdx * 110 + 40;

          const midX = (predEndX + tgtX) / 2;
          const isCritLink = computed.critical.has(depId) && computed.critical.has(task.id);
          
          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          path.setAttribute('d', `M ${predEndX} ${predY} H ${midX} V ${tgtY} H ${tgtX}`);
          path.setAttribute('fill', 'none');
          path.setAttribute('stroke', isCritLink ? '#ef4444' : '#9ca3af');
          path.setAttribute('stroke-width', '2');
          path.setAttribute('marker-end', isCritLink ? 'url(#arrow-red)' : 'url(#arrow-gray)');
          
          paths.appendChild(path);
        });
      });
    }

    function handleMouseDown(e) {
      const taskId = e.currentTarget.dataset.taskId;
      const project = getCurrentProject();
      const computed = computeCPM(project.tasks, state.minStart);
      const start = state.minStart[taskId] ?? computed.ES[taskId];

      state.dragging = {
        id: taskId,
        startX: e.clientX,
        origStart: start
      };
    }

    function handleMouseMove(e) {
      if (!state.dragging) return;

      const project = getCurrentProject();
      const task = project.tasks.find(t => t.id === state.dragging.id);
      
      // Calculate the minimum allowed start based on predecessor tasks
      let minAllowedStart = 0;
      if (task.deps.length > 0) {
        const computed = computeCPM(project.tasks, state.minStart);
        task.deps.forEach(depId => {
          const predTask = project.tasks.find(t => t.id === depId);
          if (predTask) {
            const predStart = state.minStart[depId] ?? computed.ES[depId];
            const predEnd = predStart + predTask.duration;
            minAllowedStart = Math.max(minAllowedStart, predEnd);
          }
        });
      }

      const dx = e.clientX - state.dragging.startX;
      const deltaUnits = Math.round(dx / state.unitWidth);
      const newStart = Math.max(minAllowedStart, state.dragging.origStart + deltaUnits);

      state.minStart[state.dragging.id] = newStart;
      render();
    }

    function handleMouseUp() {
      state.dragging = null;
    }

    function renderProjectSelector() {
      const container = document.getElementById('project-selector');
      container.innerHTML = '';

      PROJECTS.forEach(p => {
        const btn = document.createElement('button');
        btn.className = `project-btn ${p.id === state.currentProjectId ? 'active' : ''}`;
        btn.textContent = p.name;
        btn.onclick = () => {
          state.currentProjectId = p.id;
          state.minStart = {};
          renderProjectSelector();
          render();
        };
        container.appendChild(btn);
      });
    }

    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('mouseup', handleMouseUp);
    window.addEventListener('resize', render);

    renderProjectSelector();
    render();
  </script>
</body>
</html>